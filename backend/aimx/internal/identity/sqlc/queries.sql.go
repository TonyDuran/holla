// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptBuddyRequest = `-- name: AcceptBuddyRequest :exec
UPDATE user_relationships
SET status = 'accepted',
    updated_at = now()
WHERE user1 = LEAST($1, $2)
  AND user2 = GREATEST($1, $2)
  AND status = 'pending'
`

type AcceptBuddyRequestParams struct {
	User1   pgtype.UUID `json:"user1"`
	User1_2 pgtype.UUID `json:"user1_2"`
}

func (q *Queries) AcceptBuddyRequest(ctx context.Context, arg AcceptBuddyRequestParams) error {
	_, err := q.db.Exec(ctx, acceptBuddyRequest, arg.User1, arg.User1_2)
	return err
}

const blockUser = `-- name: BlockUser :exec
UPDATE user_relationships
SET status = 'blocked',
    updated_at = now()
WHERE user1 = LEAST($1, $2)
  AND user2 = GREATEST($1, $2)
`

type BlockUserParams struct {
	User1   pgtype.UUID `json:"user1"`
	User1_2 pgtype.UUID `json:"user1_2"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) error {
	_, err := q.db.Exec(ctx, blockUser, arg.User1, arg.User1_2)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
  username,
  email,
  password_hash,
  oauth_provider,
  display_name
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateUserParams struct {
	Username      string      `json:"username"`
	Email         string      `json:"email"`
	PasswordHash  pgtype.Text `json:"password_hash"`
	OauthProvider pgtype.Text `json:"oauth_provider"`
	DisplayName   pgtype.Text `json:"display_name"`
}

// =========================
// Users
// =========================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.OauthProvider,
		arg.DisplayName,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserAuthByUsername = `-- name: GetUserAuthByUsername :one
SELECT
  id,
  username,
  password_hash,
  oauth_provider
FROM users
WHERE username = $1
`

type GetUserAuthByUsernameRow struct {
	ID            pgtype.UUID `json:"id"`
	Username      string      `json:"username"`
	PasswordHash  pgtype.Text `json:"password_hash"`
	OauthProvider pgtype.Text `json:"oauth_provider"`
}

func (q *Queries) GetUserAuthByUsername(ctx context.Context, username string) (GetUserAuthByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserAuthByUsername, username)
	var i GetUserAuthByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.OauthProvider,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
  id,
  username,
  email,
  display_name
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	Email       string      `json:"email"`
	DisplayName pgtype.Text `json:"display_name"`
}

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.DisplayName,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT
  id,
  username,
  email,
  display_name
FROM users
WHERE username = $1
`

type GetUserByUsernameRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	Email       string      `json:"email"`
	DisplayName pgtype.Text `json:"display_name"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.DisplayName,
	)
	return i, err
}

const listBuddies = `-- name: ListBuddies :many

SELECT
  u.id,
  u.username,
  u.display_name
FROM user_relationships r
JOIN users u
  ON u.id = CASE
    WHEN r.user1 = $1 THEN r.user2
    ELSE r.user1
  END
WHERE (r.user1 = $1 OR r.user2 = $1)
  AND r.status = 'accepted'
ORDER BY u.username
`

type ListBuddiesRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	DisplayName pgtype.Text `json:"display_name"`
}

// =========================
// Buddy Lists
// =========================
func (q *Queries) ListBuddies(ctx context.Context, user1 pgtype.UUID) ([]ListBuddiesRow, error) {
	rows, err := q.db.Query(ctx, listBuddies, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBuddiesRow
	for rows.Next() {
		var i ListBuddiesRow
		if err := rows.Scan(&i.ID, &i.Username, &i.DisplayName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIncomingBuddyRequests = `-- name: ListIncomingBuddyRequests :many
SELECT
  u.id,
  u.username,
  u.display_name
FROM user_relationships r
JOIN users u
  ON u.id = r.requested_by
WHERE (r.user1 = $1 OR r.user2 = $1)
  AND r.status = 'pending'
  AND r.requested_by <> $1
ORDER BY r.created_at
`

type ListIncomingBuddyRequestsRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	DisplayName pgtype.Text `json:"display_name"`
}

func (q *Queries) ListIncomingBuddyRequests(ctx context.Context, user1 pgtype.UUID) ([]ListIncomingBuddyRequestsRow, error) {
	rows, err := q.db.Query(ctx, listIncomingBuddyRequests, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIncomingBuddyRequestsRow
	for rows.Next() {
		var i ListIncomingBuddyRequestsRow
		if err := rows.Scan(&i.ID, &i.Username, &i.DisplayName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOutgoingBuddyRequests = `-- name: ListOutgoingBuddyRequests :many
SELECT
  u.id,
  u.username,
  u.display_name
FROM user_relationships r
JOIN users u
  ON u.id = CASE
    WHEN r.user1 = $1 THEN r.user2
    ELSE r.user1
  END
WHERE r.requested_by = $1
  AND r.status = 'pending'
ORDER BY r.created_at
`

type ListOutgoingBuddyRequestsRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	DisplayName pgtype.Text `json:"display_name"`
}

func (q *Queries) ListOutgoingBuddyRequests(ctx context.Context, user1 pgtype.UUID) ([]ListOutgoingBuddyRequestsRow, error) {
	rows, err := q.db.Query(ctx, listOutgoingBuddyRequests, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOutgoingBuddyRequestsRow
	for rows.Next() {
		var i ListOutgoingBuddyRequestsRow
		if err := rows.Scan(&i.ID, &i.Username, &i.DisplayName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeBuddy = `-- name: RemoveBuddy :exec
DELETE FROM user_relationships
WHERE user1 = LEAST($1, $2)
  AND user2 = GREATEST($1, $2)
`

type RemoveBuddyParams struct {
	User1   pgtype.UUID `json:"user1"`
	User1_2 pgtype.UUID `json:"user1_2"`
}

func (q *Queries) RemoveBuddy(ctx context.Context, arg RemoveBuddyParams) error {
	_, err := q.db.Exec(ctx, removeBuddy, arg.User1, arg.User1_2)
	return err
}

const searchUsersByEmail = `-- name: SearchUsersByEmail :many
SELECT
  id,
  username,
  email,
  display_name
FROM users
WHERE email ILIKE '%' || $1 || '%'
ORDER BY email
LIMIT $2 OFFSET $3
`

type SearchUsersByEmailParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchUsersByEmailRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	Email       string      `json:"email"`
	DisplayName pgtype.Text `json:"display_name"`
}

func (q *Queries) SearchUsersByEmail(ctx context.Context, arg SearchUsersByEmailParams) ([]SearchUsersByEmailRow, error) {
	rows, err := q.db.Query(ctx, searchUsersByEmail, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersByEmailRow
	for rows.Next() {
		var i SearchUsersByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByUsername = `-- name: SearchUsersByUsername :many

SELECT
  id,
  username,
  email,
  display_name
FROM users
WHERE username ILIKE '%' || $1 || '%'
ORDER BY username
LIMIT $2 OFFSET $3
`

type SearchUsersByUsernameParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchUsersByUsernameRow struct {
	ID          pgtype.UUID `json:"id"`
	Username    string      `json:"username"`
	Email       string      `json:"email"`
	DisplayName pgtype.Text `json:"display_name"`
}

// =========================
// User Search
// =========================
func (q *Queries) SearchUsersByUsername(ctx context.Context, arg SearchUsersByUsernameParams) ([]SearchUsersByUsernameRow, error) {
	rows, err := q.db.Query(ctx, searchUsersByUsername, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersByUsernameRow
	for rows.Next() {
		var i SearchUsersByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sendBuddyRequest = `-- name: SendBuddyRequest :exec

INSERT INTO user_relationships (
  user1,
  user2,
  status,
  requested_by
) VALUES (
  LEAST($1, $2),
  GREATEST($1, $2),
  'pending',
  $1
)
ON CONFLICT DO NOTHING
`

type SendBuddyRequestParams struct {
	Requester pgtype.UUID `json:"requester"`
	Target    interface{} `json:"target"`
}

// =========================
// Buddy / Relationships
// =========================
func (q *Queries) SendBuddyRequest(ctx context.Context, arg SendBuddyRequestParams) error {
	_, err := q.db.Exec(ctx, sendBuddyRequest, arg.Requester, arg.Target)
	return err
}
